searchState.loadedDescShard("pest", 0, "pest. The Elegant Parser\nprevents implicit whitespace: inside an atomic rule, the …\nThe current atomicity of a <code>ParserState</code>.\nfrom the bottom to the top of the stack\nThe same as atomic, but inner tokens are produced as …\nThe ending <code>Position</code> of a matched <code>Rule</code>\nContains the error value\nLine iterator for Spans, created by <code>Span::lines()</code>.\nLine iterator for Spans, created by <code>Span::lines_span()</code>.\nThe current lookahead status of a <code>ParserState</code>.\nMatch direction for the stack. Used in <code>PEEK[a..b]</code>/…\nThe negative predicate, written as an exclamation mark !, …\nimplicit whitespace is enabled\nNo lookahead (i.e. it will consume input).\nContains the success value\nType alias to simplify specifying the return value of …\nA trait with a single method that parses strings.\nThe complete state of a <code>Parser</code>.\nA cursor position in a <code>&amp;str</code> which provides useful methods …\nThe positive predicate, written as an ampersand &amp;, …\nA trait which parser rules must implement.\nA span over a <code>&amp;str</code>. It is created from either two <code>Position</code>s…\nImplementation of a <code>Stack</code> which maintains popped elements …\nThe starting <code>Position</code> of a matched <code>Rule</code>\nA token generated by a <code>Parser</code>.\nfrom the top to the bottom of the stack\nAll elements in the stack.\nSafety\nTypes for different kinds of parsing failures.\nTesting tool that compares produced errors.\nTypes and iterators for parser output.\nEvery element corresponds to a snapshot, and each element …\nMerges two spans into one.\nParses a <code>&amp;str</code> starting from <code>rule</code>.\nTesting tool that compares produced tokens.\nAll elements that are in previous snapshots but may not be …\nSafety:\nConstructs useful in prefix, postfix, and infix operator …\nConstructs useful in infix operator parsing with the …\nSets the maximum call limit for the parser state to …\nSafety\nCreates a <code>ParserState</code> from a <code>&amp;str</code>, supplying it to a …\nstarting position\nending position\nmatched rule\nmatched rule\nCustom error with a message\nParse-related error type.\nDifferent kinds of parsing errors.\nWhere an <code>Error</code> has occurred.\nLine/column where an <code>Error</code> has occurred.\nGenerated parsing error with expected and unexpected <code>Rule</code>s\n<code>Error</code> was created by <code>Error::new_from_pos</code>\nLine/column pair if <code>Error</code> was created by …\n<code>Error</code> was created by <code>Error::new_from_span</code>\nLine/column pairs if <code>Error</code> was created by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the line that the error is on.\nLine/column within the input string\nLocation within the input string\nReturns the error message for <code>ErrorVariant</code>\nCreates <code>Error</code> from <code>ErrorVariant</code> and <code>Position</code>.\nCreates <code>Error</code> from <code>ErrorVariant</code> and <code>Span</code>.\nReturns the path set using <code>Error::with_path()</code>.\nRenames all <code>Rule</code>s if this is a <code>ParsingError</code>. It does …\nVariant of the error\nReturns <code>Error</code> variant with <code>path</code> which is shown when …\nShort explanation\nNegative attempts\nPositive attempts\nAn iterator over <code>Pair</code>s. It is created by <code>Pairs::flatten</code>.\nA matching pair of <code>Token</code>s and everything between them.\nAn iterator over <code>Pair</code>s. It is created by <code>pest::state</code> and …\nAn iterator over <code>Token</code>s. It is created by <code>Pair::tokens</code> and …\n<code>LineIndex</code> to make a line_offsets, each item is an byte …\nSafety\nSafety\nSafety:\nToken index into <code>queue</code>.\nAn iterator over <code>Pair</code>s. It is created by <code>Pairs::flatten</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSafety\nSafety\nReturns the <code>Tokens</code> for these pairs.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns (line, col) of pos.\nOffset (bytes) the the beginning of each line, zero-based\nA matching pair of <code>Token</code>s and everything between them.\nGet current node tag\nReturns the <code>Rule</code> of the <code>Pair</code>.\nReturns the <code>Span</code> defined by the <code>Pair</code>, <strong>without</strong> consuming it.\nCaptures a slice from the <code>&amp;str</code> defined by the token <code>Pair</code>.\nReturns the argument unchanged.\nReturns the input string of the <code>Pair</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner <code>Pairs</code> between the <code>Pair</code>, consuming it.\nReturns the <code>Span</code> defined by the <code>Pair</code>, consuming it.\nReturns the <code>line</code>, <code>col</code> of this pair start.\nSafety\nSafety\nToken index into <code>queue</code>.\nReturns the <code>Tokens</code> for the <code>Pair</code>.\nAn iterator over <code>Pair</code>s. It is created by <code>pest::state</code> and …\nCaptures a slice from the <code>&amp;str</code> defined by the starting …\nCaptures inner token <code>Pair</code>s and concatenates resulting <code>&amp;str</code>…\nFinds the first pair that has its node or branch tagged …\nReturns the iterator over pairs that have their node or …\nFlattens the <code>Pairs</code>.\nReturns the argument unchanged.\nReturns the input string of <code>Pairs</code>.\nCalls <code>U::from(self)</code>.\nPeek at the first inner <code>Pair</code> without changing the position …\nCreate a new <code>Pairs</code> iterator containing just the single <code>Pair</code>…\nReturns the <code>Tokens</code> for the <code>Pairs</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn iterator over <code>Token</code>s. It is created by <code>Pair::tokens</code> and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSafety:\nA trait with a single method that parses strings.\nParses a <code>&amp;str</code> starting from <code>rule</code>.\nprevents implicit whitespace: inside an atomic rule, the …\nThe current atomicity of a <code>ParserState</code>.\nfrom the bottom to the top of the stack\nThe same as atomic, but inner tokens are produced as …\nContains the error value\nThe current lookahead status of a <code>ParserState</code>.\nMatch direction for the stack. Used in <code>PEEK[a..b]</code>/…\nThe negative predicate, written as an exclamation mark !, …\nimplicit whitespace is enabled\nNo lookahead (i.e. it will consume input).\nContains the success value\nType alias to simplify specifying the return value of …\nThe complete state of a <code>Parser</code>.\nThe positive predicate, written as an ampersand &amp;, …\nfrom the top to the bottom of the stack\nTransformation which stops <code>Token</code>s from being generated …\nReturns the current atomicity of the <code>ParserState</code>.\nAttempts to match the end of the input. Returns <code>Ok</code> with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStarts a lookahead transformation provided by <code>f</code> from the …\nAttempts to match a single character based on a filter …\nAttempts to case-insensitively match the given string. …\nAttempts to match a single character from the given range. …\nAttempts to match the given string. Returns <code>Ok</code> with the …\nAllocates a fresh <code>ParserState</code> object to the heap and …\nNormalizes the index using its sequence’s length. …\nOptionally applies the transformation provided by <code>f</code> from …\nReturns a reference to the current <code>Position</code> of the …\nRepeatedly applies the transformation provided by <code>f</code> from …\nRestores the original state of the <code>ParserState</code> when <code>f</code> …\nWrapper needed to generate tokens. This will associate the …\nStarts a sequence of transformations provided by <code>f</code> from …\nSets the maximum call limit for the parser state to …\nAttempts to skip <code>n</code> characters forward. Returns <code>Ok</code> with the …\nAttempts to skip forward until one of the given strings is …\nDrops the top of the stack. Returns <code>Ok(Box&lt;ParserState&gt;)</code> …\nMatches the full state of the stack.\nMatches part of the state of the stack.\nMatches the full state of the stack. This method will …\nPeeks the top of the stack and attempts to match the …\nPops the top of the stack and attempts to match the …\nEvaluates the result of closure <code>f</code> and pushes the span of …\nAttempts to match the start of the input. Returns <code>Ok</code> with …\nCreates a <code>ParserState</code> from a <code>&amp;str</code>, supplying it to a …\nTag current node\nA cursor position in a <code>&amp;str</code> which provides useful methods …\nReturns <code>true</code> when the <code>Position</code> points to the end of the …\nReturns <code>true</code> when the <code>Position</code> points to the start of the …\nReturns the argument unchanged.\nCreates a <code>Position</code> at the start of a <code>&amp;str</code>.\nCalls <code>U::from(self)</code>.\nReturns the line and column number of this <code>Position</code>.\nReturns the entire line of the input that contains this …\nMatches the char at the <code>Position</code> against a specified …\nMatches the char at the <code>Position</code> against a filter function …\nCase-insensitively matches <code>string</code> from the <code>Position</code> and …\nMatches <code>char</code> <code>range</code> from the <code>Position</code> and returns <code>true</code> if a …\nMatches <code>string</code> from the <code>Position</code> and returns <code>true</code> if a …\nAttempts to create a new <code>Position</code> at the given position. …\nCreate a new <code>Position</code> without checking invariants. …\nReturns the byte position of this <code>Position</code> as a <code>usize</code>.\nSafety:\nSkips <code>n</code> <code>char</code>s from the <code>Position</code> and returns <code>true</code> if the …\nGoes back <code>n</code> <code>char</code>s from the <code>Position</code> and returns <code>true</code> if …\nSkips until one of the given <code>strings</code> is found. If none of …\nCreates a <code>Span</code> from two <code>Position</code>s.\nAssociativity of an infix binary operator, used by …\nLeft operator associativity. Evaluate expressions from …\nAn operator that corresponds to a rule.\nStruct containing operators and precedences, which can …\nProduct of calling <code>map_primary</code> on <code>PrattParser</code>, defines how …\nRight operator associativity. Evaluate expressions from …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDefines <code>rule</code> as an infix binary operator with …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLeft-Binding-Power\nLeft-Denotation\nMaps infix operators with a closure <code>infix</code>.\nMaps postfix operators with closure <code>postfix</code>.\nMaps prefix operators with closure <code>prefix</code>.\nMaps primary expressions with a closure <code>primary</code>.\nInstantiate a new <code>PrattParser</code>.\nNull-Denotation\nAdd <code>op</code> to <code>PrattParser</code>.\nThe last method to call on the provided pairs to execute …\nDefines <code>rule</code> as a postfix unary operator.\nDefines <code>rule</code> as a prefix unary operator.\nAssociativity of an <code>Operator</code>.\nLeft <code>Operator</code> associativity\nInfix operator used in <code>PrecClimber</code>.\nList of operators and precedences, which can perform …\nRight <code>Operator</code> associativity\nPerforms the precedence climbing algorithm on the <code>pairs</code> in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>Operator</code> from a <code>Rule</code> and <code>Assoc</code>.\nCreates a new <code>PrecClimber</code> from the <code>Operator</code>s contained in …\nLine iterator for Spans, created by <code>Span::lines()</code>.\nLine iterator for Spans, created by <code>Span::lines_span()</code>.\nA span over a <code>&amp;str</code>. It is created from either two <code>Position</code>s…\nCaptures a slice from the <code>&amp;str</code> defined by the <code>Span</code>.\nReturns the <code>Span</code>’s end byte position as a <code>usize</code>.\nSafety\nReturns the <code>Span</code>’s end <code>Position</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to create a new span based on a sub-range.\nReturns the input string of the <code>Span</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterates over all lines (partially) covered by this span. …\nIterates over all lines (partially) covered by this span. …\nMerges two spans into one.\nAttempts to create a new span. Will return <code>None</code> if …\nCreate a new <code>Span</code> without checking invariants. (Checked …\nSplits the <code>Span</code> into a pair of <code>Position</code>s.\nReturns the <code>Span</code>’s start byte position as a <code>usize</code>.\nSafety\nReturns the <code>Span</code>’s start <code>Position</code>.\nImplementation of a <code>Stack</code> which maintains popped elements …\nAll elements in the stack.\nThe parsing after the last snapshot was successful so …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the stack is currently empty.\nReturns the size of the stack\nEvery element corresponds to a snapshot, and each element …\nCreates a new <code>Stack</code>.\nReturns the top-most <code>&amp;T</code> in the <code>Stack</code>.\nPops the top-most <code>T</code> from the <code>Stack</code>.\nAll elements that are in previous snapshots but may not be …\nPushes a <code>T</code> onto the <code>Stack</code>.\nRewinds the <code>Stack</code> to the most recent <code>snapshot()</code>. If no …\nTakes a snapshot of the current <code>Stack</code>.\nThe ending <code>Position</code> of a matched <code>Rule</code>\nThe starting <code>Position</code> of a matched <code>Rule</code>\nA token generated by a <code>Parser</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nstarting position\nending position\nmatched rule\nmatched rule")