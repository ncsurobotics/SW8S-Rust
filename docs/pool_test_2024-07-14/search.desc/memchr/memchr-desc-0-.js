searchState.loadedDescShard("memchr", 0, "This library provides heavily optimized routines for …\nAn iterator for <code>memchr</code>.\nAn iterator for <code>memchr2</code>.\nAn iterator for <code>memchr3</code>.\nSearch for the first occurrence of a byte in a slice.\nLike <code>memchr</code>, but searches for either of two bytes instead …\nAn iterator over all occurrences of the needles in a …\nLike <code>memchr</code>, but searches for any of three bytes instead …\nAn iterator over all occurrences of the needles in a …\nAn iterator over all occurrences of the needle in a …\nThis module provides forward and reverse substring search …\nSearch for the last occurrence of a byte in a slice.\nLike <code>memrchr</code>, but searches for either of two bytes instead …\nAn iterator over all occurrences of the needles in a …\nLike <code>memrchr</code>, but searches for any of three bytes instead …\nAn iterator over all occurrences of the needles in a …\nAn iterator over all occurrences of the needle in a …\nA specialized copy-on-write byte string.\nReturn a borrowed byte string, regardless of whether this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn an owned version of this copy-on-write byte string.\nCreate a new borrowed CowBytes.\nCreate a new owned CowBytes.\nSearch for the first occurrence of a byte in a slice.\nLike <code>memchr</code>, but searches for either of two bytes instead …\nAn iterator over all occurrences of the needles in a …\nLike <code>memchr</code>, but searches for any of three bytes instead …\nAn iterator over all occurrences of the needles in a …\nAn iterator over all occurrences of the needle in a …\nSearch for the last occurrence of a byte in a slice.\nLike <code>memrchr</code>, but searches for either of two bytes instead …\nAn iterator over all occurrences of the needles in a …\nLike <code>memrchr</code>, but searches for any of three bytes instead …\nAn iterator over all occurrences of the needles in a …\nAn iterator over all occurrences of the needle in a …\nReturn <code>true</code> if <code>x</code> contains any zero byte.\nLike <code>memchr</code>, but searches for two bytes instead of one.\nLike <code>memchr</code>, but searches for three bytes instead of one.\nReturn the last index matching the byte <code>x</code> in <code>text</code>.\nLike <code>memrchr</code>, but searches for two bytes instead of one.\nLike <code>memrchr</code>, but searches for three bytes instead of one.\nRepeat the given byte into a word size number. That is, …\nSubtract <code>b</code> from <code>a</code> and return the difference. <code>a</code> should be …\nAn iterator for <code>memchr</code>.\nAn iterator for <code>memchr2</code>.\nAn iterator for <code>memchr3</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new iterator that yields all positions of needle …\nCreates a new iterator that yields all positions of needle …\nCreate a new <code>Memchr3</code> that’s initialized to zero with a …\nThis macro employs a gcc-like “ifunc” trick where by …\nCompute the position of the first matching byte from the …\nCompute the position of the first matching byte from the …\nCompute the position of the first matching byte from the …\nCompute the position of the last matching byte from the …\nCompute the position of the last matching byte from the …\nCompute the position of the last matching byte from the …\nSubtract <code>b</code> from <code>a</code> and return the difference. <code>a</code> should be …\nCompute the position of the first matching byte from the …\nCompute the position of the first matching byte from the …\nCompute the position of the first matching byte from the …\nCompute the position of the last matching byte from the …\nCompute the position of the last matching byte from the …\nCompute the position of the last matching byte from the …\nSubtract <code>b</code> from <code>a</code> and return the difference. <code>a</code> should be …\nAutomatically detect whether a heuristic prefilter should …\nA special case for empty needles. An empty needle always …\nA special case for empty needles. An empty needle always …\nAn iterator over non-overlapping substring matches.\nAn iterator over non-overlapping substring matches in …\nA single substring searcher fixed to a particular needle.\nA builder for constructing non-default forward or reverse …\nA single substring reverse searcher fixed to a particular …\nA collection of facts computed about a search needle.\nNever used a prefilter in substring search.\nThis is used whenever the needle is a single byte. In this …\nThis is used whenever the needle is a single byte. In this …\nPrefilter controls whether heuristics are used to …\nThe internal implementation of a forward substring …\nConfiguration for substring search.\nThe internal implementation of a reverse substring …\nTwo-Way is the generic work horse and is what provides our …\nTwo-Way is the generic work horse and is what provides our …\nConvert this finder into its borrowed variant.\nConvert this finder into its borrowed variant.\nBuild a forward finder using the given needle from the …\nBuild a reverse finder using the given needle from the …\nReturns the index of the first occurrence of the given …\nReturns the index of the first occurrence of this needle …\nImplements forward substring search by selecting the …\nReturns an iterator over all non-overlapping occurrences …\nReturns an iterator over all occurrences of a substring in …\nCalls Two-Way on the given haystack/needle.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this iterator into its owned variant, such that it …\nConvert this iterator into its owned variant, such that it …\nConvert this finder into its owned variant, such that it …\nConvert this finder into its owned variant, such that it …\nThe actual substring implementation in use.\nThe actual substring implementation in use.\nReturns the needle that this finder searches for.\nReturns the needle that this finder searches for.\nThe actual needle we’re searching for.\nThe actual needle we’re searching for.\nCreate a new finder for the given needle.\nCreate a new reverse finder for the given needle.\nCreate a new finder builder with default settings.\nA Rabin-Karp hash of the needle.\nA Rabin-Karp hash of the needle.\nA collection of facts computed on the needle that are …\nWhen searching with an empty needle, this gets set to <code>None</code> …\nConfigure the prefilter setting for the finder.\nThis permits changing the behavior of the prefilter, since …\nReturn a fresh prefilter state that can be used with this …\nA prefilter function, if it was deemed appropriate.\nThe offsets of “rare” bytes detected in the needle.\nReturns the index of the last occurrence of the given …\nReturns the index of the last occurrence of this needle in …\nImplements reverse substring search by selecting the …\nReturns a reverse iterator over all non-overlapping …\nReturns a reverse iterator over all occurrences of a …\nThe implementation of the forward vector accelerated …\nThe maximum length of a needle required for this algorithm.\nThe minimum length of a needle required for this …\nSubtract <code>b</code> from <code>a</code> and return the difference. <code>a</code> must be …\nReturns the argument unchanged.\nSearches the given haystack for the given needle. The …\nSearch for an occurrence of two rare bytes from the needle …\nCalls <code>U::from(self)</code>.\nAccepts a chunk-relative offset and returns a haystack …\nReturns the minimum length of haystack that is needed for …\nCreate a new “generic simd” forward searcher. If one …\nAutomatically detect whether a heuristic prefilter should …\nThe maximum frequency rank permitted for the fallback …\nThe minimum number of skip attempts to try before …\nThe minimum amount of bytes that skipping must average.\nNever used a prefilter in substring search.\nA combination of prefilter effectiveness state, the …\nPrefilter controls whether heuristics are used to …\nA prefilter function.\nThe type of a prefilter function. All prefilters must …\nPrefilterState tracks state associated with the …\nCall this prefilter on the given haystack with the given …\nCall the underlying prefilter function with the given …\nDetermine which prefilter function, if any, to use.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a fresh prefilter state that is always inert.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if and only if this state indicates that a …\nReturn the minimum length of the haystack in which a …\nCreate a new prefilter function from the function pointer …\nCreate a fresh prefilter state.\nInformation about a needle, such as its RK hash and rare …\nThe actual prefilter function.\nReturn true if and only if this prefilter should be used.\nThe total number of bytes that have been skipped.\nThe number of skips that has been executed. This is always …\nState that tracks the effectiveness of a prefilter.\nUpdate this state with the number of bytes skipped on the …\nLook for a possible occurrence of needle. The position …\nSubtract <code>b</code> from <code>a</code> and return the difference. <code>a</code> must be …\nThe implementation of the forward vector accelerated …\nSearch for an occurrence of two rare bytes from the needle …\nSearch for an occurrence of two rare bytes and the first …\nAccepts a chunk-relative offset and returns a haystack …\nAn AVX2 accelerated candidate finder for single-substring …\nAn SSE2 accelerated candidate finder for single-substring …\nA Rabin-Karp hash. This might represent the hash of a …\nA hash derived from a needle.\nAdd a byte to this hash.\nRemove a byte from this hash. The given needle hash should …\nReturn true if the hashes are equivalent.\nSearch for the first occurrence of needle in haystack …\nSearch for the first occurrence of needle in haystack …\nCreate a new Rabin-Karp hash for the given needle for use …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new hash from the bytes given for use in forward …\nCreate a new hash from the bytes given for use in reverse …\nThe actual hash.\nThe factor needed to multiply a byte by in order to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether RK is believed to be very fast for the given …\nReturns true if the given needle is a prefix of the given …\nReturns true if the given needle is a suffix of the given …\nCreate a new hash that represents the empty string.\nCreate a new Rabin-Karp hash for the given needle for use …\nSearch for the last occurrence of needle in haystack using …\nSearch for the last occurrence of needle in haystack using …\nAdd ‘new’ and remove ‘old’ from this hash. The …\nA heuristic frequency based detection of rare bytes for …\nReturn the byte frequency rank of each byte. The higher …\nReturn the rare bytes in the given needle in the forward …\nLike as_rare_ordered_usize, but returns the offsets as …\nReturn the rare offsets such that the first offset is …\nReturn the rare offsets as usize values in the order in …\nDetect the leftmost offsets of the two rarest bytes in the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn the heuristical frequency rank of the given byte. A …\nThe leftmost offset of the rarest byte in the needle, …\nThe leftmost offset of the second rarest byte in the …\nThis occurs when the given candidate byte indicates that …\nA bitset used to track whether a particular byte exists in …\nTwo-Way search in the forward direction.\nExtract the largest lexicographic suffix from a string.\nExtract the smallest lexicographic suffix from a string.\nThis occurs when no decision to accept or skip the …\nTwo-Way search in the reverse direction.\nA representation of the amount we’re allowed to shift by …\nThis occurs when the given candidate byte excludes the …\nA suffix extracted from a needle along with its period.\nThe kind of suffix to extract.\nThe result of comparing corresponding bytes between two …\nAn implementation of the TwoWay substring search …\nA small bitset used as a quick prefilter (in addition to …\nReturns true if and only if the given candidate byte …\nReturn true if and only if the given byte might be in this …\nA critical position in needle. Specifically, this position …\nFind the position of the first occurrence of this searcher…\nCompute the shift for a given needle in the forward …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a searcher that uses the Two-Way algorithm by …\nCreate a searcher that uses the Two-Way algorithm by …\nCreate a new set from the given needle.\nThe period of this suffix.\nThe starting position of this suffix.\nCompute the shift for a given needle in the reverse …\nFind the position of the last occurrence of this searcher…\nThe amount we shift by in the Two-Way search algorithm. …\nReturns true if and only if needle is a prefix of haystack.\nReturns true if and only if needle is a suffix of haystack.\nReturn true if and only if x.len() == y.len() &amp;&amp; x[i] == y[…\nA trait for describing vector operations used by …\n_mm_and_si128 or _mm256_and_si256\n_mm_cmpeq_epi8 or _mm256_cmpeq_epi8\n_mm_loadu_si128 or _mm256_loadu_si256\n_mm_movemask_epi8 or _mm256_movemask_epi8\n_mm_set1_epi8 or _mm256_set1_epi8\nAn AVX accelerated vectorized substring search routine …\nThe implementation of find marked with the appropriate …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the minimum length of haystack that is needed for …\nCreate a new “generic simd” forward searcher. If one …\nAn SSE accelerated vectorized substring search routine …\nThe implementation of find marked with the appropriate …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the minimum length of haystack that is needed for …\nCreate a new “generic simd” forward searcher. If one …")