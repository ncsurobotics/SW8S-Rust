<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The maximum length of a needle required for this algorithm."><title>MAX_NEEDLE_LEN in memchr::memmem::genericsimd - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="memchr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../memchr/index.html">memchr</a><span class="version">2.5.0</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In memchr::memmem::genericsimd</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Constant <a href="../../index.html">memchr</a>::<wbr><a href="../index.html">memmem</a>::<wbr><a href="index.html">genericsimd</a>::<wbr><a class="constant" href="#">MAX_NEEDLE_LEN</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/memchr/memmem/genericsimd.rs.html#35">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub(crate) const MAX_NEEDLE_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a> = 32;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The maximum length of a needle required for this algorithm.</p>
<p>In reality, there is no hard max here. The code below can handle any
length needle. (Perhaps that suggests there are missing optimizations.)
Instead, this is a heuristic and a bound guaranteeing our linear time
complexity.</p>
<p>It is a heuristic because when a candidate match is found, memcmp is run.
For very large needles with lots of false positives, memcmp can make the
code run quite slow.</p>
<p>It is a bound because the worst case behavior with memcmp is multiplicative
in the size of the needle and haystack, and we want to keep that additive.
This bound ensures we still meet that bound theoretically, since it’s just
a constant. We aren’t acting in bad faith here, memcmp on tiny needles
is so fast that even in pathological cases (see pathological vector
benchmarks), this is still just as fast or faster in practice.</p>
<p>This specific number was chosen by tweaking a bit and running benchmarks.
The rare-medium-needle, for example, gets about 5% faster by using this
algorithm instead of a prefilter-accelerated Two-Way. There’s also a
theoretical desire to keep this number reasonably low, to mitigate the
impact of pathological cases. I did try 64, and some benchmarks got a
little better, and others (particularly the pathological ones), got a lot
worse. So… 32 it is?</p>
</div></details></section></div></main></body></html>